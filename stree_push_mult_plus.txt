struct coolstree
{
    //-------------------- changable part --------------------
    typedef db base;
    base default_mult = 1;
    base default_plus = 0;
    base default_t = 0;
    //inline base f(base a, base b) { return a + b; }
    //--------------------------------------------------------


    //data
    int n;
    vector<base> t;
    vector<base> mult;
    vector<base> plus;


    //initializers
    coolstree() {}
    coolstree(vector<base>& ar)
    {
        n = 1;
        while (ar.sz > n) n <<= 1;

        t.rr(n + n, default_t);
        mult.rr(n + n, default_mult);
        plus.rr(n + n, default_plus);

        for (int i = 0; i < ar.sz; ++i) t[i + n] = ar[i];
        for (int i = n - 1; i; --i) t[i] = t[i + i] + t[i + i + 1];
    }
    coolstree(int nn)
    {
        vector<base> tmp(nn + nn, default_t);
        *this = coolstree(tmp);
    }


    //push
    void push(int v, int tl, int tr)
    {
        t[v] *= mult[v];
        t[v] += plus[v] * (tr - tl);


        if (v < n)
        {
            mult[2 * v] *= mult[v];
            mult[2 * v + 1] *= mult[v];
            plus[2 * v] *= mult[v];
            plus[2 * v + 1] *= mult[v];
            plus[2 * v] += plus[v];
            plus[2 * v + 1] += plus[v];
        }
        mult[v] = default_mult;
        plus[v] = default_plus;
    }

    //set
    void set_m(int v, int tl, int tr, int l, int r, base x)
    {
        if (tl == l && tr == r) { mult[v] *= x; plus[v] *= x; return; }

        push(v, tl, tr);
        int m = (tl + tr) >> 1;

        if (r <= m) set_m(2 * v, tl, m, l, r, x);
        else if (l >= m) set_m(2 * v + 1, m, tr, l, r, x);
        else
        {
            set_m(2 * v, tl, m, l, m, x);
            set_m(2 * v + 1, m, tr, m, r, x);
        }

        if (v < n)
        {
            push(2 * v, tl, m);
            push(2 * v + 1, m, tr);
        }
        t[v] = t[v + v] + t[v + v + 1];
    }

    void set_p(int v, int tl, int tr, int l, int r, base x)
    {
        if (tl == l && tr == r) { plus[v] += x; return; }

        push(v, tl, tr);
        int m = (tl + tr) >> 1;

        if (r <= m) set_p(2 * v, tl, m, l, r, x);
        else if (l >= m) set_p(2 * v + 1, m, tr, l, r, x);
        else
        {
            set_p(2 * v, tl, m, l, m, x);
            set_p(2 * v + 1, m, tr, m, r, x);
        }

        if (v < n)
        {
            push(2 * v, tl, m);
            push(2 * v + 1, m, tr);
        }
        t[v] = t[v + v] + t[v + v + 1];
    }

    //get
    base get(int v, int tl, int tr, int l, int r)
    {
        push(v, tl, tr);
        if (tl == l && tr == r) return t[v];
        int m = (tl + tr) >> 1;

        if (r <= m) return get(2 * v, tl, m, l, r);
        else if (l >= m) return get(2 * v + 1, m, tr, l, r);
        else
        {
            base ans = default_t;
            ans += get(2 * v, tl, m, l, m);
            ans += get(2 * v + 1, m, tr, m, r);
            return ans;
        }
    }

    //just for convinience
    inline base get(int i) { return get(1, 0, n, i, i + 1); }
    inline void set_m(int i, base x) { set_m(1, 0, n, i, i + 1, x); }
    inline void set_p(int i, base x) { set_p(1, 0, n, i, i + 1, x); }
    inline base get(int l, int r) { return get(1, 0, n, l, r + 1); }
    inline void set_m(int l, int r, base x) { set_m(1, 0, n, l, r + 1, x); }
    inline void set_p(int l, int r, base x) { set_p(1, 0, n, l, r + 1, x); }
};


