struct coolstree
{
    //-------------------- changable part --------------------
    typedef ll base;
    base default_mod = 0;
    base default_t = 0;
    base(*f)(base a, base b) = [](base a, base b) { return max(a,b); };
    base(*g)(base a, base b) = [](base a, base b) { return a + b; };
    //--------------------------------------------------------


    //data
    int n;
    vector<base> t;
    vector<base> mod;


    //initializers
    coolstree() {}
    coolstree(vector<base>& ar)
    {
        n = 1;
        while (ar.sz > n) n <<= 1;

        t.rr(n + n, default_t);
        mod.rr(n + n, default_mod);

        for (int i = 0; i < ar.sz; ++i) t[i + n] = f(ar[i], default_t);
        for (int i = n - 1; i; --i) t[i] = f(t[i + i], t[i + i + 1]);
    }
    coolstree(int nn)
    {
        vector<base> tmp(nn, default_t);
        *this = coolstree(tmp);
    }


    //push
    void push(int v, int tl, int tr)
    {
        t[v] = g(t[v], mod[v]);

        if (v < n)
        {
            mod[2 * v] = g(mod[v], mod[2 * v]);
            mod[2 * v + 1] = g(mod[v], mod[2 * v + 1]);
        }
        mod[v] = default_mod;
    }

    //set
    void set(int v, int tl, int tr, int l, int r, base x)
    {
        if (tl == l && tr == r) { mod[v] = g(mod[v], x); return; }

        push(v, tl, tr);
        int m = (tl + tr) >> 1;

        if (r <= m) set(2 * v, tl, m, l, r, x);
        else if (l >= m) set(2 * v + 1, m, tr, l, r, x);
        else
        {
            set(2 * v, tl, m, l, m, x);
            set(2 * v + 1, m, tr, m, r, x);
        }

        if (v < n)
        {
            push(2 * v, tl, m);
            push(2 * v + 1, m, tr);
        }
        t[v] = f(t[v + v], t[v + v + 1]);
    }

    //get
    base get(int v, int tl, int tr, int l, int r)
    {
        push(v, tl, tr);
        if (tl == l && tr == r) return t[v];
        int m = (tl + tr) >> 1;

        if (r <= m) return get(2 * v, tl, m, l, r);
        else if (l >= m) return get(2 * v + 1, m, tr, l, r);
        else
        {
            base ans = default_t;
            ans = f(ans, get(2 * v, tl, m, l, m));
            ans = f(ans, get(2 * v + 1, m, tr, m, r));
            return ans;
        }
    }

    //just for convinience
    inline base get(int i) { return get(1, 0, n, i, i + 1); }
    inline void set(int i, base x) { set(1, 0, n, i, i + 1, x); }
    inline base get(int l, int r) { return get(1, 0, n, l, r + 1); }
    inline void set(int l, int r, base x) { set(1, 0, n, l, r + 1, x); }
};
